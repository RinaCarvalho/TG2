{"prompt": "The Winter holiday will be here soon. Mr. Chanek wants to decorate his house's wall with ornaments. The wall can be represented as a binary string a of length n. His favorite nephew has another binary string b of length m (m \u2264 n).\n\nMr. Chanek's nephew loves the non-negative integer k. His nephew wants exactly k occurrences of b as substrings in a. \n\nHowever, Mr. Chanek does not know the value of k. So, for each k (0 \u2264 k \u2264 n - m + 1), find the minimum number of elements in a that have to be changed such that there are exactly k occurrences of b in a.\n\nA string s occurs exactly k times in t if there are exactly k different pairs (p,q) such that we can obtain s by deleting p characters from the beginning and q characters from the end of t. Write a function to determine the minimum number of elements needed to be changed for each k. The function must receive two integers n and m, and two binary strings a and b, of lengths n and m. The function must return a list with (n - m + 2) integers, where the (k+1)-th integer denotes the minimal number of elements in a that must be changed so there are exactly k occurrences of b as substrings in a. If no amount of changes is capable of satisfying k occurrences, the (k+1)-th integer must be -1.\n\nExamples:\n\nInput: ['9', '3', '100101011', '101']\nOutput: [0, 2, 1, 3, 2, 2, 4, 3]\n\nInput: ['9', '3', '101101011', '111']\nOutput: [1, 1, 0, 1, 6, -1, -1, -1]", "response": "def min_changes(n, m, a, b):\n    def z_algorithm(s):\n        n = len(s)\n        z = [0]*n\n        z[0] = n\n        l, r = 0, 0\n        for i in range (1,n):\n            if i>r:\n                l, r = i, i\n                while r<n and s[r-l]==s[r]:\n                    r+=1\n                z[i] = r-l\n                r-=1\n            else:\n                k = i-l\n                if z[k]<r-i+1:\n                    z[i] = z[k]\n                else:\n                    l = i\n                    while r<n and s[r-l]==s[r]:\n                        r+=1\n                    z[i] = r-l\n                    r-=1\n        return z\n    a = [int(i) for i in a]\n    b = [int(i) for i in b]\n    b = b[::-1]\n    a = a[::-1]\n    dp1 = [0]*(n+2)\n    dp2 = [0]*(n+2)\n    sum1 = [0]*(n+2)\n    sum2 = [0]*(n+2)\n    p = [0]*(n+2)\n    ans = [0]*(n+2)\n    z = z_algorithm(b+a)\n    z = z[m-1:]\n    for i in range(n-1,-1,-1):\n        dp1[i] = min(dp1[i+1],z[i]+n+1-(i+1+m))\n        dp2[i] = min(dp2[i+1],1-z[i]+n+1-(i+1+m))\n        sum1[i] = sum1[i+1]\n        sum2[i] = sum2[i+1]\n        if z[i]>=m:\n            sum1[i]+=1-n+1-(i+1+m)\n            sum2[i]+=1\n    na = [0]*(m+2)\n    nb = [0]*(n+2)\n    na[m-1] = nb[n-1] = m\n    for i in range (m-2,-1,-1):\n        if b[i]!=b[i+1]:\n            na[i] = i+1\n        else:\n            na[i] = na[i+1]\n    for i in range (n-2,-1,-1):\n        if a[i]!=b[m-1]:\n            nb[i] = i+1\n        else:\n            nb[i] = nb[i+1]\n    for i in range (n+5):\n        ans[i] = int(1e9)\n    ans[0] = n-nb[0]\n    for _k in range (1,n-m+2):\n        j = n-_k-m+1\n        while p[j]<n and nb[p[j]]>=j:\n            p[j]+=1\n        if p[j]==n:\n            for _i in range (_k,n-m+2):\n                ans[_i] = -1\n            break\n        v = nb[p[j]]-j+1\n        ans[_k] = min(ans[_k],ans[_k-1]+v)\n        if sum2[j]<=m-_k:\n            x = ans[_k-1]\n            l = 0\n            r = sum1[j]+1\n            while r-l>1:\n                mid = (l+r)//2\n                if mid*m+sum2[j]-sum2[p[min(n,p[j]+mid)-1]]<=x:\n                    l = mid\n                else:\n                    r = mid\n            for _i in range (_k,r,n-m+2):\n                ans[_i] = -1\n            ans[_k+l] = min(ans[_k+l],x)\n    return ans[:n-m+2]"}
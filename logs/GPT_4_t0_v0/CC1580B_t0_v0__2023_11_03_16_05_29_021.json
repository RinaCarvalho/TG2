{"prompt": "Let c_1, c_2, \u2026, c_n be a permutation of integers 1, 2, \u2026, n. Consider all subsegments of this permutation containing an integer x. Given an integer m, we call the integer x good if there are exactly m different values of maximum on these subsegments. A permutation is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array) and [1,3,4] is also not a permutation (n=3 but there is 4 in the array). A sequence a is a subsegment of a sequence b if a can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end. Given four integers n, m, k and p, write a function to count the number of permutations of length n with exactly k good numbers, modulo p. The function must receive four integers n, m, k and p and return an integer.", "response": "\ndef count_good_numbers(n, m, k, p):\n    factorial = [1]\n    for i in range(1, n + 1):\n        factorial.append((factorial[-1] * i) % p)\n\n    inverse = [1]\n    for i in range(1, n + 1):\n        inverse.append((inverse[-1] * pow(i, p - 2, p)) % p)\n\n    def choose(n, k):\n        if not 0 <= k <= n:\n            return 0\n        return (factorial[n] * inverse[k] * inverse[n - k]) % p\n\n    dp = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    dp[0][0] = 1\n    for all_places in range(n):\n        for good_places in range(all_places + 1):\n            curr = dp[all_places][good_places]\n            if all_places + 1 - good_places <= m - 1:\n                dp[all_places + 1][good_places + 1] += curr\n                dp[all_places + 1][good_places + 1] %= p\n            dp[all_places + 1][good_places] += curr * max(good_places + 1, m)\n            dp[all_places + 1][good_places] %= p\n\n    result = 0\n    for all_places in range(k, n + 1):\n        for good_places in range(k):\n            curr = dp[all_places][good_places] * choose(n, all_places) % p\n            curr = curr * factorial[n - all_places] % p\n            curr = curr * pow(factorial[all_places] * factorial[n - all_places], p - 2, p) % p\n            result += curr\n            result %= p\n    return result\n"}
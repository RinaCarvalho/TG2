{
    "prompt": "Let c_1, c_2, \u2026, c_n be a permutation of integers 1, 2, \u2026, n. Consider all subsegments of this permutation containing an integer x. Given an integer m, we call the integer x good if there are exactly m different values of maximum on these subsegments. A permutation is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array) and [1,3,4] is also not a permutation (n=3 but there is 4 in the array). A sequence a is a subsegment of a sequence b if a can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end. Given four integers n, m, k and p, write a function to count the number of permutations of length n with exactly k good numbers, modulo p. The function must receive four integers n, m, k and p and return an integer.\n\nExamples:\n\nInput: ['4', '3', '2', '10007']\nOutput: 4\n\nInput: ['6', '4', '1', '769626776']\nOutput: 472\n\nInput: ['66', '11', '9', '786747482']\nOutput: 206331312\n\nInput: ['99', '30', '18', '650457567']\nOutput: 77365367",
    "response": "def count_good_permutations(n, m, k, p):\n    MOD = p\n    fact = [0]*(n+5)\n    invfact = [0]*(n+5)\n    good = [[0]*(m+5) for _ in range(n+5)]\n    choose = [[0]*(n+5) for _ in range(n+5)]\n    sum_choose = [[0]*(n+5) for _ in range(n+5)]\n    fact[0] = invfact[0] = 1\n    for i in range(1, n+5):\n        fact[i] = fact[i-1]*i%MOD\n        invfact[i] = pow(fact[i], MOD-2, MOD)\n    def C(n, k):\n        if k < 0 or k > n: return 0\n        return fact[n]*invfact[k]%MOD*invfact[n-k]%MOD\n    for i in range(n+5):\n        for j in range(i+1):\n            choose[i][j] = C(i, j)\n            sum_choose[i][j] = (choose[i][j] + (sum_choose[i][j-1] if j-1 >= 0 else 0)) % MOD\n    good[0][0] = 1\n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            good[i][j] = (good[i][j] + good[i-1][j-1]*(j-1)) % MOD\n            if i-2 >= 0:\n                good[i][j] = (good[i][j] + good[i-2][j-1]*(i-1)) % MOD\n            good[i][j]=(good[i][j]+good[i-1][j]*max(0, i-j))%MOD\n    res = 0\n    for i in range(k, n+1):\n        for j in range(m, n+1):\n            cur = good[i][j]\n            cur = cur * choose[n][i] % MOD * choose[n-i][j] % MOD\n            cur = cur * fact[i] % MOD * fact[j] % MOD\n            cur = cur * sum_choose[n-j][n-j] % MOD\n            res = (res + cur) % MOD\n    return res\n",
    "test_results": "Test failed: result 0 != 4 (expected)"
}
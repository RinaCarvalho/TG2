{"prompt": "Let c_1, c_2, \u2026, c_n be a permutation of integers 1, 2, \u2026, n. Consider all subsegments of this permutation containing an integer x. Given an integer m, we call the integer x good if there are exactly m different values of maximum on these subsegments. A permutation is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array) and [1,3,4] is also not a permutation (n=3 but there is 4 in the array). A sequence a is a subsegment of a sequence b if a can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end. Given four integers n, m, k and p, write a function to count the number of permutations of length n with exactly k good numbers, modulo p. The function must receive four integers n, m, k and p and return an integer.\n\nExamples:\n\nInput: ['4', '3', '2', '10007']\nOutput: 4\n\nInput: ['6', '4', '1', '769626776']\nOutput: 472\n\nInput: ['66', '11', '9', '786747482']\nOutput: 206331312\n\nInput: ['99', '30', '18', '650457567']\nOutput: 77365367", "response": "def count_good_permutations(n, m, k, p):\n    frac = [0]*(n+10)\n    ifac = [0]*(n+10)\n    dp = [ [ [0]*(m+2) for _ in range(m+2) ] for _ in range(n+10) ]\n    C = [ [0]*(m+2) for _ in range(m+2) ]\n    frac[0] = ifac[0] = 1\n    for i in range(1, n+10):\n        frac[i] = (frac[i-1]*i)%p\n        ifac[i] = pow(frac[i], p-2, p)\n    for i in range(m+2):\n        C[i][0] = 1\n        for j in range(1, i+1):\n            C[i][j] = (C[i-1][j] + C[i-1][j-1])%p\n    dp[0][0][0] = 1\n    for i in range(n):\n        for j in range(min(i, m)+1):\n            for l in range(min(j, k)+1):\n                if dp[i][j][l]:\n                    cur = dp[i][j][l]\n                    if j+1<=m:\n                        dp[i+1][j+1][l+1] = (dp[i+1][j+1][l+1]+cur)%p\n                        dp[i+1][j+1][l+1] = (dp[i+1][j+1][l+1]+cur*C[j+1][l+1]*frac[n-i-1]%p*ifac[n-i]%p)\n                    if l<=j and l<=k:\n                        dp[i+1][j][l] = (dp[i+1][j][l]+cur*(j-l+1)%p)%p\n                        dp[i+1][j][l] = (dp[i+1][j][l]+cur*C[j][l]*frac[n-i-1]%p*ifac[n-i]%p)\n                    if l+1<=j and l+1<=k:\n                        dp[i+1][j][l+1] = (dp[i+1][j][l+1]+cur)%p\n                        dp[i+1][j][l+1] = (dp[i+1][j][l+1]+cur*C[j][l+1]*frac[n-i-1]%p*ifac[n-i]%p)\n    return dp[n][m][k] % p"}